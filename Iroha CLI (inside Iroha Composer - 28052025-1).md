# **Internal Conversation (protocol)**

The question is: **Can we get the funcotin of the CLI back in this new Composer environment ?** I repeat:

Its about the problems with Iroha ... as discussed here ...

[https://chatgpt.com/c/6827b6cc-1628-8012-9072-3c3ebc5cafc7](https://chatgpt.com/c/6827b6cc-1628-8012-9072-3c3ebc5cafc7)  and

[https://chatgpt.com/c/6825942b-a6bc-8012-8dd0-3a15384e9dab](https://chatgpt.com/c/6825942b-a6bc-8012-8dd0-3a15384e9dab) 

We are in troubles now since one months, as its not at all clear what the developers did to get it running ... so we requested with an issue a full documentation

[https://github.com/soramitsu/iroha2-block-explorer-web/issues/99](https://github.com/soramitsu/iroha2-block-explorer-web/issues/99) 

and even offered a detailled installation.md file

[https://github.com/DigitClopedia2024/iroha2-block-explorer-web/blob/1e45d258f9c37cbf0d1bb07fef1e73225fe7139a/installation.md](https://github.com/DigitClopedia2024/iroha2-block-explorer-web/blob/1e45d258f9c37cbf0d1bb07fef1e73225fe7139a/installation.md) 

Yet the problems are penetrant, and the developer of the backend (Block Explorer) even decided to come into action and started to create this "all runs in a docker environment".

We have forked the repository ...

[https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-) 

The start was very easy, just clone the repository and start to run the docker-compose.yml file with this code [https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/blob/master/docker-compose.yml](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/blob/master/docker-compose.yml) 

*Or here the copy:*
<details>
<summary>
Unfold for the docker-compose.yml file code:
</summary>

\# TODO: set up shutdown/restart policies

services:

\# Iroha

\#

\# NOTE: These are mostly generated by kagami swarm

irohad0:

image: hyperledger/iroha:2.0.0-rc.2.0

environment:

CHAIN: 00000000-0000-0000-0000-000000000000

PUBLIC\_KEY: ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE

PRIVATE\_KEY: 802620834BCEC4477C62ABC9EFBB6B147A5699CAFEE223DF385A8C53D9EBD320A8DBBF

P2P\_PUBLIC\_ADDRESS: irohad0:1337

P2P\_ADDRESS: 0.0.0.0:1337

API\_ADDRESS: 0.0.0.0:8080

GENESIS\_PUBLIC\_KEY: ed0120A5F4F231A1E8ACA399ACC5D967C37A672AC57CBB90DB72BCCC910A6EFC460380

TRUSTED\_PEERS: '\["ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618@irohad3:1340","ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D@irohad1:1338","ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F@irohad2:1339"\]'

GENESIS\_PRIVATE\_KEY: 80262074F42221C8E6DF699E64F1034C4B0E4AA38ADB614A72664E1314207BB193DDFD

GENESIS: /tmp/genesis.signed.scale

TOPOLOGY: '\["ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE","ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618","ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D","ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F"\]'

volumes:

\- ./config:/config:ro

init: true

healthcheck:

test: test $(curl \-s http://127.0.0.1:8080/status/blocks) \-gt 0

interval: 2s

timeout: 1s

retries: 30

start\_period: 4s

command: |-

/bin/sh \-c "

EXECUTOR\_RELATIVE\_PATH=$(jq \-r '.executor' /config/genesis.json) && \\\\

EXECUTOR\_ABSOLUTE\_PATH=$(realpath \\"/config/$$EXECUTOR\_RELATIVE\_PATH\\") && \\\\

WASM\_DIR\_RELATIVE\_PATH=$(jq \-r '.wasm\_dir' /config/genesis.json) && \\\\

WASM\_DIR\_ABSOLUTE\_PATH=$(realpath \\"/config/$$WASM\_DIR\_RELATIVE\_PATH\\") && \\\\

jq \\\\

\--arg executor \\"$$EXECUTOR\_ABSOLUTE\_PATH\\" \\\\

\--arg wasm\_dir \\"$$WASM\_DIR\_ABSOLUTE\_PATH\\" \\\\

\--argjson topology \\"$$TOPOLOGY\\" \\\\

'.executor \= $$executor | .wasm\_dir \= $$wasm\_dir | .topology \= $$topology' /config/genesis.json \\\\

\>/tmp/genesis.json && \\\\

kagami genesis sign /tmp/genesis.json \\\\

\--public-key $$GENESIS\_PUBLIC\_KEY \\\\

\--private-key $$GENESIS\_PRIVATE\_KEY \\\\

\--out-file $$GENESIS \\\\

&& \\\\

exec irohad

"

irohad1:

image: hyperledger/iroha:2.0.0-rc.2.0

environment:

CHAIN: 00000000-0000-0000-0000-000000000000

PUBLIC\_KEY: ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D

PRIVATE\_KEY: 802620DF8B3645801D2D807C77F737DE4375EB56A726835B136A4BFA7FB792880796B9

P2P\_PUBLIC\_ADDRESS: irohad1:1338

P2P\_ADDRESS: 0.0.0.0:1338

API\_ADDRESS: 0.0.0.0:8081

GENESIS\_PUBLIC\_KEY: ed0120A5F4F231A1E8ACA399ACC5D967C37A672AC57CBB90DB72BCCC910A6EFC460380

TRUSTED\_PEERS: '\["ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE@irohad0:1337","ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618@irohad3:1340","ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F@irohad2:1339"\]'

volumes:

\- ./config:/config:ro

init: true

irohad2:

image: hyperledger/iroha:2.0.0-rc.2.0

environment:

CHAIN: 00000000-0000-0000-0000-000000000000

PUBLIC\_KEY: ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F

PRIVATE\_KEY: 8026205E02883BF7AD1B0C5549CB34E2E96D381A578E9E10A6B441389BFF7846D74C9B

P2P\_PUBLIC\_ADDRESS: irohad2:1339

P2P\_ADDRESS: 0.0.0.0:1339

API\_ADDRESS: 0.0.0.0:8082

GENESIS\_PUBLIC\_KEY: ed0120A5F4F231A1E8ACA399ACC5D967C37A672AC57CBB90DB72BCCC910A6EFC460380

TRUSTED\_PEERS: '\["ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE@irohad0:1337","ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618@irohad3:1340","ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D@irohad1:1338"\]'

volumes:

\- ./config:/config:ro

init: true

irohad3:

image: hyperledger/iroha:2.0.0-rc.2.0

environment:

CHAIN: 00000000-0000-0000-0000-000000000000

PUBLIC\_KEY: ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618

PRIVATE\_KEY: 80262089815D6FFCF714FE333353D521D3185F0B5240DFA9BF22B6A04EB538AC0AF204

P2P\_PUBLIC\_ADDRESS: irohad3:1340

P2P\_ADDRESS: 0.0.0.0:1340

API\_ADDRESS: 0.0.0.0:8083

GENESIS\_PUBLIC\_KEY: ed0120A5F4F231A1E8ACA399ACC5D967C37A672AC57CBB90DB72BCCC910A6EFC460380

TRUSTED\_PEERS: '\["ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE@irohad0:1337","ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D@irohad1:1338","ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F@irohad2:1339"\]'

volumes:

\- ./config:/config:ro

init: true

\# Explorer

iroha\_explorer\_backend:

build: ./explorer\_backend

environment:

IROHA\_EXPLORER\_ACCOUNT: ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland

IROHA\_EXPLORER\_ACCOUNT\_PRIVATE\_KEY: 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53

IROHA\_EXPLORER\_TORII\_URLS: http://irohad0:8080,http://irohad1:8081,http://irohad2:8082,http://irohad3:8083

IROHA\_EXPLORER\_IP: 0.0.0.0

IROHA\_EXPLORER\_PORT: 8123

init: true

iroha\_explorer\_web:

build: ./explorer\_web

environment:

BACKEND\_HOST: iroha\_explorer\_backend

BACKEND\_PORT: 8123

ports:

\- 8124:8080

\# Sample data producer

producer:

build: ./producer

depends\_on:

irohad0:

condition: service\_healthy

environment:

TORII\_URL: http://irohad0:8080

\# TODO: is this needed?

init: true
</details>
\---------------------------------

**You can see in the respository, that the developer copies all three repositories and arranges that they get installed (from blockchain Iroha V2, to backend (Block explorer) to front end (Web UI Explorer).**

I checked inside the containers, if there is the copy of the respositories, but nothing ... e.g. for starting the blockchain it needs the docker-compose.yaml file inside the defaults sub-directory ... but there is nothing ... I used the search function, but not such file existing. Or I lookced for the cargo.toml file

[https://github.com/DigitClopedia2024/iroha-version-2.0.0-rc.2.0-/blob/main/Cargo.toml](https://github.com/DigitClopedia2024/iroha-version-2.0.0-rc.2.0-/blob/main/Cargo.toml) 

which is delivered with the respository for the Iroha V2 blockchain, and itjust needs top copy this file into a new directory, and start it with "iroha" command, and then its possible to do the whole setting (domains, token names, token volume (minting), burning, transfer of ownership etc ...)

[https://docs.iroha.tech/get-started/operate-iroha-2-via-cli.html](https://docs.iroha.tech/get-started/operate-iroha-2-via-cli.html) 

We had already 2 installations, but the Json errors / 502 Gateway errors had been persistent with the web front end

[https://github.com/soramitsu/iroha2-block-explorer-web/issues/98](https://github.com/soramitsu/iroha2-block-explorer-web/issues/98) 

Finally via an A.I. I got the hint, that its not possible for this front end, as it runs in docker ,to communicate with the backend, which does not run in docker ... and obviously the developer of the backend has understood this also and took it in own hands to conduct all together into one docker environment.

**The "producer" container I mentioned ... is this one:**

[https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/tree/master/producer](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/tree/master/producer) 

*The code is this:*

<details>
import { Client } from "@iroha/client";

import \* as types from "@iroha/core/data-model";

import { assert } from "@std/assert";

import { delay } from "@std/async";

const TORII\_URL \= Deno.env.get("TORII\_URL");

assert(TORII\_URL, "Please set TORII\_URL env var");

const TXS\_CHUNK \= 20;

const PUSH\_DELAY \= 1500;

const CHAIN \= 00000000-0000-0000-0000-000000000000;

const ACCOUNT \= ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland;

const ACCOUNT\_PRIVATE\_KEY \= 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53;

const client \= new Client({

chain: CHAIN,

authority: types.AccountId.parse(ACCOUNT),

authorityPrivateKey: types.PrivateKey.fromMultihash(ACCOUNT\_PRIVATE\_KEY),

toriiBaseURL: new URL(TORII\_URL),

});

console.info("Producing dummy transactions...");

while (true) {

await produceChunk(async () \=\> {

await client.transaction(

types.Executable.Instructions(\[

types.InstructionBox.Log({

msg: "Hello, world\!",

level: types.Level.DEBUG,

}),

\]),

{

nonce: new types.NonZero(\~\~(Math.random() \* 100\_000)),

metadata: \[{ key: new types.Name("foo"), value: types.Json.fromValue(\["a", 1, false, null, \[\], {}\]) }\],

},

).submit({ verify: false });

});

await delay(PUSH\_DELAY);

}

async function produceChunk(cb: () \=\> Promise\<void\>) {

await Array.fromAsync({ length: TXS\_CHUNK }, () \=\> cb());

}
</details>
\----------------------------------

As I understand, **it simulates the CLI ...** but that of course it not the target we have. We dont need just a simulation.

So we even have not found a way, to get access to this client inside this new docker environment ??

*The installation went very smoothly and the start gave following containers:*
<details>
✔ Container iroha\_explorer\_compose-05-2025--irohad0-1 Healthy29.2s

✔ Container iroha\_explorer\_compose-05-2025--irohad1-1 Started13.6s

✔ Container iroha\_explorer\_compose-05-2025--irohad2-1 Started21.5s

✔ Container iroha\_explorer\_compose-05-2025--iroha\_explorer\_backend-1 Started17.7s

✔ Container iroha\_explorer\_compose-05-2025--iroha\_explorer\_web-1 Started21.3s

✔ Container iroha\_explorer\_compose-05-2025--irohad3-1 Started16.9s

✔ Container iroha\_explorer\_compose-05-2025--producer-1 Started28.0s
</details>
Docker container names and IDs running ...
<details>
$ docker ps

CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES

b396c97d0c46 iroha\_explorer\_compose-05-2025--producer "/tini \-- docker-ent…" 35 seconds ago Up 9 seconds iroha\_explorer\_compose-05-2025--producer-1

fa3c3a4b2864 hyperledger/iroha:2.0.0-rc.2.0 "irohad" 40 seconds ago Up 19 seconds iroha\_explorer\_compose-05-2025--irohad2-1

5e52912c42fb iroha\_explorer\_compose-05-2025--iroha\_explorer\_backend "/bin/sh \-c 'iroha\_e…" 40 seconds ago Up 23 seconds iroha\_explorer\_compose-05-2025--iroha\_explorer\_backend-1

66abf9c11c7e iroha\_explorer\_compose-05-2025--iroha\_explorer\_web "caddy run \--config …" 40 seconds ago Up 19 seconds 80/tcp, 443/tcp, 2019/tcp, 443/udp, 0.0.0.0:8124-\>8080/tcp, :::8124-\>8080/tcp iroha\_explorer\_compose-05-2025--iroha\_explorer\_web-1

3cd3ff176416 hyperledger/iroha:2.0.0-rc.2.0 "irohad" 40 seconds ago Up 28 seconds iroha\_explorer\_compose-05-2025--irohad1-1

85089cad06a8 hyperledger/iroha:2.0.0-rc.2.0 "/bin/sh \-c '\\n EX…" 40 seconds ago Up 24 seconds (healthy) iroha\_explorer\_compose-05-2025--irohad0-1

3cee90b60cd2 hyperledger/iroha:2.0.0-rc.2.0 "irohad" 40 seconds ago Up 23 seconds iroha\_explorer\_compose-05-2025--irohad3-1
</details>
\---------------------------------

As we can see, also for 3 nodes (e.g. \-irohad1-1, \-irohad2-1, \-irohad3-1 ), the developer has created their own containers while the \-irohad0-1 is that of the blockchain.

He has given his own backend solutoin the same port address of the frontned (originally it had its own), but with a different end-point. The frontend is accessible via broswer at 127.0.0.1:8124 while the backend is accessible via 127.0.0.1:8124/api/docs (see screenshots) ...

What the developer also did, and thats in my understanding also not really helpful, that he pre-defined domain owners/assets via a genesis.json file. Normally this is a pre-setting inside the CLI of the blockchain.

[https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/blob/master/config/genesis.json](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/blob/master/config/genesis.json) 

The code is this:
<details>
{

"chain": "00000000-0000-0000-0000-000000000000",

"executor": "executor.wasm",

"parameters": {

"sumeragi": {

"block\_time\_ms": 2000,

"commit\_time\_ms": 4000,

"max\_clock\_drift\_ms": 1000

},

"block": {

"max\_transactions": 512

},

"transaction": {

"max\_instructions": 4096,

"smart\_contract\_size": 4194304

},

"executor": {

"fuel": 55000000,

"memory": 55000000

},

"smart\_contract": {

"fuel": 55000000,

"memory": 55000000

}

},

"instructions": \[

{

"Register": {

"Domain": {

"id": "wonderland",

"logo": null,

"metadata": {

"key": "value"

}

}

}

},

{

"Register": {

"Account": {

"id": "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland",

"metadata": {

"key": "value"

}

}

}

},

{

"Register": {

"Account": {

"id": "ed012004FF5B81046DDCCF19E2E451C45DFB6F53759D4EB30FA2EFA807284D1CC33016@wonderland",

"metadata": {

"key": "value"

}

}

}

},

{

"Register": {

"AssetDefinition": {

"id": "rose\#wonderland",

"spec": {

"scale": null

},

"mintable": "Infinitely",

"logo": null,

"metadata": {}

}

}

},

{

"Register": {

"Domain": {

"id": "garden\_of\_live\_flowers",

"logo": null,

"metadata": {}

}

}

},

{

"Register": {

"Account": {

"id": "ed0120E9F632D3034BAB6BB26D92AC8FD93EF878D9C5E69E01B61B4C47101884EE2F99@garden\_of\_live\_flowers",

"metadata": {}

}

}

},

{

"Register": {

"AssetDefinition": {

"id": "cabbage\#garden\_of\_live\_flowers",

"spec": {

"scale": null

},

"mintable": "Infinitely",

"logo": null,

"metadata": {}

}

}

},

{

"Mint": {

"Asset": {

"object": "13",

"destination": "rose\#\#ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland"

}

}

},

{

"Mint": {

"Asset": {

"object": "44",

"destination": "cabbage\#garden\_of\_live\_flowers\#ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland"

}

}

},

{

"Grant": {

"Permission": {

"object": {

"name": "CanSetParameters",

"payload": null

},

"destination": "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland"

}

}

},

{

"Grant": {

"Permission": {

"object": {

"name": "CanRegisterDomain",

"payload": null

},

"destination": "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland"

}

}

}

\],

"wasm\_dir": "libs",

"wasm\_triggers": \[\],

"topology": \[\]

}
</details>
\---------------------------

Also in the **docker-compose.yml file** the developer pre-defined the public/private keys and hidden port addresses where the two other applicatoins (backend/frontend) can communciate with, see extract from this yml file:


PUBLIC\_KEY: ed012004F79C976A13CFBD72DBBAA255C657E92655E95D8FBD21C0A1578536F5685CCE
PRIVATE\_KEY: 802620834BCEC4477C62ABC9EFBB6B147A5699CAFEE223DF385A8C53D9EBD320A8DBBF
P2P\_PUBLIC\_ADDRESS: irohad0:1337
P2P\_ADDRESS: 0.0.0.0:1337
API\_ADDRESS: 0.0.0.0:8080
GENESIS\_PUBLIC\_KEY: ed0120A5F4F231A1E8ACA399ACC5D967C37A672AC57CBB90DB72BCCC910A6EFC460380

TRUSTED\_PEERS: '\["ed0120185C4176C23EE7F6F7B216E1C68D410982B400A86B0D709A845B39CBDCB56618@irohad3:1340","ed01207ED0E6A6AF830A033C596C57B06B776BF29B5A08FD7A13F3AD5BE8AE6128065D@irohad1:1338","ed0120E961C026752E68DCFE0BA9D47491AE853F7E3AE1775818F4D11DB8489C3C0C9F@irohad2:1339"\]'

GENESIS\_PRIVATE\_KEY: 80262074F42221C8E6DF699E64F1034C4B0E4AA38ADB614A72664E1314207BB193DDFD

\----------------------

**In my understanding the basic idea might be right, to glue all 3 parts together within a docker environment. But the basic funciotn of CLI should still be available.**

What you suggest so the function of CLI is available same as if the blockchain Iroha V2 would be installed on its own ? 

*It's completely understandable that you're facing difficulties regaining CLI functionality for Iroha within this new Docker Composer environment, especially after previous installation issues. The move to an "all runs in Docker" approach by the backend developer aims to solve integration problems, but it can indeed obscure direct access to underlying tools like the Iroha CLI.*

Here's how you can regain access to the Iroha CLI within your Docker Compose setup, and some explanations for the observed behavior:

### **Why the CLI Isn't Directly Available**

When you run an application in Docker (especially with Docker Compose), each `service` in your `docker-compose.yml` runs in its own isolated container. The `irohad0` service (and `irohad1`, `irohad2`, `irohad3`) is running the `hyperledger/iroha:2.0.0-rc.2.0` image. This image *contains* the `irohad` binary (the Iroha node itself), but it doesn't necessarily expose the `iroha-cli` tool directly for interactive use from your host machine.

The `producer` container is a client that interacts with the Iroha nodes via their API (Torii URL), not directly via the Iroha CLI. It's a programmatic way to send transactions, which serves a similar *purpose* to the CLI in terms of interacting with the blockchain, but it's not the interactive command-line interface you're looking for.

### **How to Get the CLI Functionality Back**

You have a few primary ways to access the Iroha CLI or perform CLI-like operations within your Docker Compose environment:

#### **1\. Exec into the Iroha Container (Most Direct Way)**

This is the most common and direct method to get an interactive shell inside a running container and then use the tools available within that container.

**Ensure your Docker Compose services are running:**  
Bash  
docker-compose up \-d

1. (You've already done this, and it looks like your containers are healthy.)  
2. **Find the name of the Iroha container:** You already ran `docker ps`, which is perfect. Look for the container running the `hyperledger/iroha:2.0.0-rc.2.0` image. For example, your output shows `iroha_explorer_compose-05-2025--irohad0-1`.

**Execute a shell inside the container:** Use `docker exec` to open an interactive bash or sh shell inside the running Iroha node container. Since `irohad0` is your main node, let's target that one:

Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--irohad0-1 /bin/bash  
\# Or, if bash isn't available, try:  
\# docker exec \-it iroha\_explorer\_compose-05-2025--irohad0-1 sh

3. Once inside the container's shell, you should have access to the `iroha` (or `iroha-cli`) command if it's included in that specific Docker image.

**Use the Iroha CLI:** From within the container's shell, you can now run `iroha` commands. You will need to specify the peer address (which will be `127.0.0.1:8080` if connecting to `irohad0` from within its own container, or `irohad0:8080` if you were to exec into another container that could reach `irohad0` via the Docker network).  
Example of using `iroha-cli` (if it's named `iroha-cli` within the image):  
Bash  
iroha-cli \--account\_name admin@test \--peer localhost:8080

4. You'll need to know the account name and its private key or have access to it for signing transactions. The `genesis.json` defines `ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland` as an account. The corresponding private key is in your `docker-compose.yml` for `iroha_explorer_backend`.  
   **Important Note:** The `hyperledger/iroha:2.0.0-rc.2.0` image might not contain the `iroha-cli` directly by default. The `iroha-cli` is often a separate binary. If `iroha` or `iroha-cli` command is not found, you'll need to install it inside the container (not recommended as changes are lost on restart) or use a dedicated `iroha-client-cli` image.

#### **2\. Add a Dedicated CLI Service to your `docker-compose.yml`**

This is a more robust and recommended approach if you need frequent CLI access. Iroha often provides a specific Docker image for its client CLI (e.g., `hyperledger/iroha:client-cli` or similar).

**Add a new service to your `docker-compose.yml`:** You would add a new service that uses the Iroha CLI image. This service can then connect to your running `irohad` nodes.  
```
YAML  
\# ... (existing services) ...

iroha\_cli\_tool:  
  image: hyperledger/iroha:2.0.0-rc.2.0 \# Or look for a dedicated client-cli image if available  
  \# If the image doesn't contain the CLI by default, you might need to build it  
  \# or specify a command that runs the CLI on startup.  
  \# Or, a simpler approach, if the main iroha image has \`iroha\` binary,  
  \# you can just reuse that image and provide the CLI command.  
  command: tail \-f /dev/null \# Keep the container running  
  environment:  
    \# These are important for the CLI to know how to connect  
    TORII\_URL: http://irohad0:8080 \# Or list all nodes: http://irohad0:8080,http://irohad1:8081,...  
    IROHA\_EXPLORER\_ACCOUNT: ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland  
    IROHA\_EXPLORER\_ACCOUNT\_PRIVATE\_KEY: 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53  
  depends\_on:  
    irohad0:  
      condition: service\_healthy
```

1. **Start or restart your Docker Compose services:**  
```
Bash  
docker-compose up \-d \--build iroha\_cli\_tool \# Build and start only this service, or \`docker-compose up \-d\` for all
```
2. **Exec into this new CLI container:**  
```
Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--iroha\_cli\_tool-1 /bin/bash
```
3. Now, from within this container, you should be able to run `iroha-cli` commands, potentially utilizing the environment variables you set for configuration.

#### **3\. Use Iroha Client Libraries (for programmatic interaction)**

While you specifically asked for CLI functionality, it's worth reiterating that the `producer` container demonstrates interacting with Iroha via a client library (Deno/TypeScript in that case). Iroha also provides client SDKs for Rust, Python, Java/Kotlin, and JavaScript.

If your goal is to automate tasks or integrate Iroha with other applications, using these client libraries from a separate script or application (which could also be containerized) is the idiomatic way to interact with the Iroha network programmatically. You would configure these clients to connect to the `TORII_URL`s of your Iroha nodes (e.g., `http://localhost:8080` from your host, or `http://irohad0:8080` from another container on the same Docker network).

### **Addressing Your Other Points**

* **"I checked inside the containers, if there is the copy of the respositories, but nothing..."** This is expected. Docker images are built from `Dockerfile`s, and generally, they only contain the compiled binaries and necessary runtime files, not the entire source code repository. The `build: ./explorer_backend` line in `docker-compose.yml` tells Docker to build an image from the `explorer_backend` directory, implying a `Dockerfile` exists there which compiles and copies the backend application into the image. Similarly for `explorer_web` and `producer`. The `irohad` images are pulled directly from Docker Hub (`hyperledger/iroha:2.0.0-rc.2.0`).  
* **`docker-compose.yaml` inside `defaults` sub-directory for blockchain:** The `docker-compose.yml` you provided is the *main* Docker Compose file that orchestrates *all* the services. The Iroha blockchain itself doesn't need a `docker-compose.yaml` inside its running container. It's configured via environment variables and mounted volumes (`./config:/config:ro`) as defined in the main `docker-compose.yml`. The `genesis.json` is loaded from the mounted `/config` directory within the `irohad0` container.  
* **`cargo.toml` file:** Similar to the repository comment above, `cargo.toml` is a Rust project file for building. It's used *during the build process* of the Iroha binary, not typically present or needed in the final running Docker image unless you're trying to recompile something inside the container (which you generally wouldn't do for a running node).  
* **JSON errors / 502 Gateway errors:** Your AI hint was likely correct. When services are in separate environments (one in Docker, one outside), network communication often breaks down. Docker containers live on their own internal network. For a Docker container to talk to something *outside* the Docker network, or for something *outside* to talk to something *inside*, ports need to be explicitly published (`ports:`) or networking configurations adjusted. The developer's move to put everything in Docker Compose addresses this by allowing services to resolve each other by their service names (e.g., `irohad0`, `iroha_explorer_backend`) within the shared Docker network. The `ports: - 8124:8080` for `iroha_explorer_web` exposes port 8080 *inside* the container to port 8124 on your host machine, making the web UI accessible from your browser.  
* **"Producer" simulating the CLI:** Yes, the `producer` is essentially a simple program (written in Deno/TypeScript) that uses the Iroha client library to send transactions to the Iroha network. This demonstrates a programmatic way to interact, but it's not the interactive command-line interface `iroha-cli` that you're looking for to manually issue commands.  
* **Pre-defined domains/assets in `genesis.json`:** This is standard practice for setting up an initial blockchain state. For permissioned blockchains like Iroha, you typically define initial domains, accounts, and asset definitions in a genesis block. This ensures a consistent starting point for the network. While you *can* create these via the CLI after the network starts, defining them in `genesis.json` simplifies deployment and ensures the network is immediately functional with a base set of entities. The CLI would be used for *further* interactions and changes after this initial setup.

In summary, to get the Iroha CLI back, your best bet is to `docker exec` into the `irohad0` container (or a dedicated `iroha-cli` container if you add one to your `docker-compose.yml`) and run the `iroha` or `iroha-cli` command from there. Remember to configure the CLI with the correct `TORII_URL` (usually `localhost:8080` from inside the `irohad0` container itself, or `irohad0:8080` if accessing from another container on the same Docker network) and the necessary account details for signing transactions.

**I alrady checked the containers, nothing is copied inside ... no toml file read my hints in the upper post. So I cant setup there cli.**

It has a reason, because the devleoper simulates the blockchain dfinitoin via dummie configuratitons, see uppder comment.

*You are absolutely correct to point out that the `Cargo.toml` file (and implicitly, the full source code for building the Iroha CLI) would not be present **inside** the running `hyperledger/iroha:2.0.0-rc.2.0` container. My apologies if my previous explanation wasn't clear enough on that specific point. You won't find the source code for the Iroha node or its CLI within the compiled Docker image.*

The `hyperledger/iroha:2.0.0-rc.2.0` image contains the **`irohad`** binary, which is the Iroha blockchain *node* itself. It's the executable that runs the blockchain. It does *not* typically contain the separate `iroha-cli` client application by default.

This is a crucial distinction and explains why you couldn't just `docker exec` in and immediately find `iroha-cli` or `iroha`.

### **The Problem: The `hyperledger/iroha` Image Doesn't Include `iroha-cli`**

The base `hyperledger/iroha` image is designed to run the Iroha peer (`irohad`), not to provide an interactive CLI tool. The CLI is a separate client application.

### **Solutions to Get the CLI Functionality Back (Given This Constraint)**

Since the `iroha-cli` isn't in the node image, you need a different strategy.

#### **1\. Download/Build `iroha-cli` on Your Host Machine**

This is the most straightforward way to get the CLI *outside* the Docker environment, allowing you to interact with the Iroha nodes running in Docker.

1. **Check Iroha Documentation for CLI Installation:** The official Iroha documentation (which you linked, `https://docs.iroha.tech/get-started/operate-iroha-2-via-cli.html`) is your best source for how to install the `iroha-cli` on your host machine.  
   * **Pre-compiled Binaries:** They often provide pre-compiled binaries for various operating systems. This is usually the easiest way. Look for a "Releases" section on the Iroha GitHub, or check their documentation for download links.  
   * **Building from Source:** If binaries aren't available for your specific OS or version, you'll need to build it from source. This typically involves:  
     * Installing Rust and Cargo (Rust's package manager).  
     * Cloning the Iroha 2 repository (the main one, not your forked explorer).  
     * Navigating to the `client_cli` or `tools/cli` directory within the Iroha 2 repository.  
     * Running `cargo build --release` to compile the CLI.  
2. Once you have the `iroha-cli` binary on your host machine, you can use it.  
3. **Configure `iroha-cli` to Connect to Dockerized Nodes:** When you run `iroha-cli` from your host, it needs to know how to reach the Iroha nodes running inside Docker. You achieve this using the `ports` mapping in your `docker-compose.yml`.  
   * Your `irohad0` container exposes its API on port `8080` *inside* the container.  
   * However, your `docker-compose.yml` does *not* expose port `8080` of `irohad0` to your host machine. It only exposes `8124` for the `iroha_explorer_web` service.

**To connect the `iroha-cli` from your host to `irohad0`, you need to add a `ports` mapping to the `irohad0` service in your `docker-compose.yml`:**  
```
YAML  
services:  
  irohad0:  
    image: hyperledger/iroha:2.0.0-rc.2.0  
    \# ... other configurations ...  
    ports:  
      \- "8080:8080" \# Expose Iroha API port to the host  
    \# ... rest of irohad0 configuration ...  
```
After adding this, run `docker-compose up -d --force-recreate irohad0` to apply the change.  
Now, from your host machine, you can use `iroha-cli` and point it to `localhost:8080`:  
```
Bash  
\# Example using iroha-cli on your host  
iroha-cli \--peer localhost:8080 \--account\_id ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland \--private\_key 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53 instruction \<your\_instruction\>
```
4. You'll need to provide the `account_id` and `private_key` for signing transactions, which you can get from your `docker-compose.yml` and `genesis.json`.

#### **2\. Create a Custom Docker Image with `iroha-cli`**

If you want to keep everything containerized, or if installing Rust/Cargo on your host is undesirable, you can create a new Docker image that specifically includes the `iroha-cli`.

**Create a new `Dockerfile` for the CLI:** In a new directory (e.g., `iroha_cli_docker/`), create a `Dockerfile`:  
```
Dockerfile  
\# Start from a base image that supports Rust/Cargo if you need to build  
FROM rust:latest as builder

WORKDIR /app

\# Clone the Iroha repository \- adjust to the correct branch/tag for 2.0.0-rc.2.0  
RUN git clone https://github.com/hyperledger/iroha.git .  
RUN git checkout 2.0.0-rc.2.0 \# Or the specific tag/commit that matches your irohad version

\# Build the CLI  
WORKDIR /app/client\_cli \# Or wherever the CLI source is located in the repo  
RUN cargo build \--release

\# Create a small runtime image  
FROM debian:bookworm-slim  
WORKDIR /usr/local/bin

\# Copy the compiled CLI binary  
COPY \--from=builder /app/client\_cli/target/release/iroha /usr/local/bin/iroha-cli

\# Set up environment variables for the CLI (optional, but convenient)  
ENV TORII\_URL="http://irohad0:8080" \# Default, can be overridden  
ENV IROHA\_EXPLORER\_ACCOUNT="ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland"  
ENV IROHA\_EXPLORER\_ACCOUNT\_PRIVATE\_KEY="802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"

\# Set default command if you want it to run interactively  
CMD \["/bin/bash"\]
```
1. *Self-correction:* The path to `iroha-cli` in Iroha 2.0.0-rc.2.0 is often `/client_cli/` or `/tools/cli/`. You'll need to verify this in the actual Iroha 2.0.0-rc.2.0 repository.

**Add a new service to your `docker-compose.yml`:**  
```
YAML  
\# ... (existing services) ...

iroha\_custom\_cli:  
  build: ./iroha\_cli\_docker \# Path to the directory with your Dockerfile  
  command: tail \-f /dev/null \# Keep the container running for you to exec into  
  environment:  
    \# Override if needed, but they are set in the Dockerfile  
    \# TORII\_URL: http://irohad0:8080  
  depends\_on:  
    irohad0:  
      condition: service\_healthy
```
2. **Build and Run:**  
```Bash  
docker-compose up \-d \--build iroha\_custom\_cli
```

3. **Exec into your custom CLI container:**  
```
Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--iroha\_custom\_cli-1 /bin/bash
```
Now, inside this container, you should be able to run `iroha-cli` commands. Since this container is on the same Docker network as `irohad0`, it can resolve `irohad0` by its service name.  
```
Bash  
\# Inside the iroha\_custom\_cli container  
iroha-cli \--peer irohad0:8080 \--account\_id $IROHA\_EXPLORER\_ACCOUNT \--private\_key $IROHA\_EXPLORER\_ACCOUNT\_PRIVATE\_KEY instruction \<your\_instruction\>
```
4. ### **Why the Developer's Approach Makes Sense (From Their Perspective)**

From the backend developer's perspective, packaging everything into Docker Compose offers several advantages, even if it feels restrictive for CLI access:

1. **Reproducibility:** The exact same environment and configuration are spun up every time, preventing "it works on my machine" issues.  
2. **Isolation:** Services are isolated, reducing conflicts between dependencies.  
3. **Simplified Deployment:** A single `docker-compose up` command brings up the entire application stack.  
4. **Network Configuration:** Docker Compose handles the internal networking between services automatically, which is why the backend and frontend can communicate with `irohad0` using service names (e.g., `irohad0:8080`) without manual IP configuration.  
5. **Genesis Configuration:** Using `genesis.json` for initial setup is indeed standard and ensures a consistent starting state for the blockchain, especially for a multi-node setup. It streamlines the deployment of a pre-configured network.

While this approach is great for quick deployment and testing of the *integrated system*, it often overlooks the need for granular, interactive CLI access by users who want to modify or explore the blockchain beyond what the UIs offer.

Choose the method that best suits your workflow. For quick, occasional CLI use, installing it on your host and exposing the Iroha API port is probably the fastest. If you need a more integrated containerized solution or want to share the CLI environment, building a custom Docker image for it is the way to go.

**I dont think this works ... something outside of a docker environment cant communicate with apps inside a docke renvironment. thats why the developer strated to do it. because we had 3 different environments.**

we have the situation, that because of different environments, the communicatoin between the 3 apps do not work adequately ...

Application A \= Iroha blockchain : Runs via docker-compose with Port A

Application B \= block explorer : Backend picks up the data from Applicatoin a via API / Port A (programmed in rust) and offers the data records of applicatoin A (in ints sqlite database) via Port B to Application C

Applicatoin C \= Web UI front end : Frontned runs via docker command (not docker compose) with Port C

So we had 3 different environments:

\- docker-compose

\- nginx web server

\- docker

... and this created the conflicts that we didnt get the records from the SQlite databse (Block explorer) visible in the front end.

*You're hitting on a fundamental point about Docker networking, and you're right to question my initial assumption about external communication if not explicitly handled. Let me clarify this crucial aspect.*

**You are absolutely correct that applications in different, isolated Docker environments (or a Docker environment and the host) cannot communicate *by default*. This is precisely why the developer moved everything into one `docker-compose.yml` file.**

My apologies for any confusion. Let's break down the networking and how it affects your ability to use the CLI.

### **The Core Problem: Docker Network Isolation**

When you run separate `docker-compose` projects, or a `docker-compose` project alongside individual `docker run` commands, each creates its own isolated network.

* **Scenario 1 (Your previous setup):**  
  * `docker-compose` network (for Iroha A)  
  * Host network (for Block Explorer B)  
  * Another `docker` network (for Web UI C) They couldn't talk to each other without explicit port mappings and potentially complex network configurations (like Docker overlays or `host` networking for containers, which can have security implications). This was the source of your JSON/502 errors.  
* **Scenario 2 (The new Composer setup):**  
  * **All services (`irohad0`, `irohad1`, `iroha_explorer_backend`, `iroha_explorer_web`, `producer`) are now part of the *same* Docker network defined by your single `docker-compose.yml` file.** This is the key. Within this single Docker Compose network, services can communicate with each other using their service names (e.g., `iroha_explorer_backend` can reach `irohad0:8080`). This is why the developer's new setup successfully integrates everything.

### **Re-evaluating CLI Access within the New Unified Docker Compose Environment**

Now, let's address your core question: "Can we get the function of the CLI back in this new Composer environment?"

Yes, you absolutely can, but the method depends on whether you want the CLI *inside* a container or *outside* on your host machine.

#### **Option A: Running the CLI *Inside* the Docker Compose Network (Recommended for "Back in this new Composer environment")**

This means the CLI will also be a container within your `docker-compose` setup. It will share the same network, allowing it to communicate with the `irohad` nodes using their service names.

This is the approach of **"Adding a Dedicated CLI Service to your `docker-compose.yml`"**, as I described previously.

1. **The `hyperledger/iroha:2.0.0-rc.2.0` image itself doesn't contain `iroha-cli`.** This is the critical piece of information. The `irohad` image only has the node. So, you cannot simply `docker exec` into `irohad0` and run `iroha-cli`.  
2. **You need a Docker image that *contains* the `iroha-cli` binary.**  
   * **Best Case: Official `iroha-cli` Docker Image:** The Iroha project *might* provide a separate Docker image specifically for their CLI. You would search Docker Hub for `hyperledger/iroha-cli` or similar. If one exists for your specific `2.0.0-rc.2.0` version, that's the easiest.  
   * **Next Best: Build your own `iroha-cli` Docker Image:** If no official CLI image exists, you'll have to build one yourself. This is what I outlined in "Create a Custom Docker Image with `iroha-cli`" in my previous response. This involves:  
     * Creating a new `Dockerfile` that clones the Iroha 2 repository.  
     * Builds the `iroha-cli` binary within the Docker build process.  
     * Copies the compiled `iroha-cli` into a lightweight base image.  
3. Let's assume you create such a `Dockerfile` in a new directory, say `cli_docker_build/`.

**Integrate the Custom CLI Image into your `docker-compose.yml`:**  
```YAML  
\# Existing services...  
\# irohad0, irohad1, irohad2, irohad3, iroha\_explorer\_backend, iroha\_explorer\_web, producer

iroha\_cli\_tool:  
  build: ./cli\_docker\_build \# Path to your Dockerfile for building the CLI image  
  command: tail \-f /dev/null \# Keep the container running indefinitely  
  environment:  
    \# These are crucial for the CLI inside the container to connect  
    \# It needs the account and private key for signing transactions  
    CLI\_ACCOUNT\_ID: ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland  
    CLI\_PRIVATE\_KEY: 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53  
    \# No need for TORII\_URL here if you pass it directly to \`iroha-cli\` command  
    \# or if it's set as an ENV in the custom Dockerfile.  
  depends\_on:  
    irohad0:  
      condition: service\_healthy \# Ensure Iroha node is up before CLI is useful```

4. **Run Docker Compose:**  
```Bash  
docker-compose up \-d \--build iroha\_cli\_tool \# Build and start the new CLI service  
\# Or just \`docker-compose up \-d\` to restart everything if you made other changes```

5. **Access the CLI:** Once the `iroha_cli_tool` container is running, you can `docker exec` into it:  

```Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--iroha\_cli\_tool-1 /bin/bash
```  
Inside this shell, you can now run `iroha-cli` commands, directing them to the Iroha node using its **service name** on the shared Docker network:  
```Bash  
\# Inside the CLI container  
iroha-cli \--peer irohad0:8080 \--account\_id $CLI\_ACCOUNT\_ID \--private\_key $CLI\_PRIVATE\_KEY instruction RegisterDomain '{"Domain": {"id": "my\_new\_domain"}}'
```
6. This approach maintains the unified Docker Compose environment, which is the developer's desired outcome for seamless communication between all components.

#### **Option B: Running the CLI *Outside* the Docker Compose Environment**

This is the scenario where you want to run `iroha-cli` directly on your host machine (your laptop, VM, etc.).

1. **Install `iroha-cli` on your host:** As discussed, you'll need to download a pre-compiled binary or build it from source on your host OS. This has nothing to do with Docker.

**Expose Iroha API Ports to the Host:** This is the *critical step* that enables communication. For your host machine to talk to a container, the container's port *must be published* to the host. Your current `docker-compose.yml` only publishes `iroha_explorer_web`'s port 8080 to host's 8124 (`8124:8080`). The `irohad` nodes (like `irohad0` on port 8080\) are *not* exposed to the host by default.  
**You *must* modify your `docker-compose.yml` to expose `irohad0`'s API port:**  
```YAML  
services:  
  irohad0:  
    image: hyperledger/iroha:2.0.0-rc.2.0  
    environment:  
      \# ... existing environment variables ...  
      API\_ADDRESS: 0.0.0.0:8080 \# This means irohad listens on all internal network interfaces  
    ports:  
      \- "8080:8080" \# \<-- ADD THIS LINE to expose port 8080 to your host  
    \# ... rest of irohad0 configuration ...
```
2. After adding this, run `docker-compose up -d --force-recreate irohad0` (or `docker-compose up -d`) to apply the port mapping.

**Use `iroha-cli` on your host:** Now, from your host machine, you can connect to `irohad0` via `localhost:8080`:  
```Bash  
iroha-cli \--peer localhost:8080 \--account\_id ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland \--private\_key 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53 instruction \<your\_instruction\>
```
3. **Conclusion:**

The developer's move to a single Docker Compose file solved the inter-application communication issues *within* Docker. To get the CLI back, you either:

1. **Run the CLI as another service *within* that same Docker Compose file** (Option A \- preferred for a fully containerized solution). This requires building a custom Docker image for the CLI unless an official one exists.  
2. **Run the CLI on your host machine, but explicitly expose the Iroha node's API port (`8080`) in your `docker-compose.yml`** (Option B \- simpler if you just need host access).

**Both options are valid ways to get CLI functionality, but Option A aligns more with the "all runs in Docker" philosophy and prevents reliance on host-specific installations.** Option B is quicker if you have the CLI binary ready on your host.

It only needs a **simple toml file**:

[https://github.com/DigitClopedia2024/iroha-version-2.0.0-rc.2.0-/blob/main/defaults/client.toml](https://github.com/DigitClopedia2024/iroha-version-2.0.0-rc.2.0-/blob/main/defaults/client.toml) 
```TOML
chain \= "00000000-0000-0000-0000-000000000000"
torii\_url \= "http://127.0.0.1:8080/"
\[basic\_auth\]
web\_login \= "mad\_hatter"
password \= "ilovetea"
\[account\]
domain \= "wonderland"
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```

**Because the public and private keys are built seperatelly, and then one has to add manually the new domain and create a new password combination. This Iroha client is just being started with the command "iroha", and thats it. NO big installatoin.**

*You're providing crucial information here\! The `client.toml` file and the simple `iroha` command are key. This changes things significantly from assuming a separate `iroha-cli` binary.*

If the Iroha client is simply started with `iroha` and configured via `client.toml`, it implies that the `iroha` executable within the `hyperledger/iroha` image (which you're using for your `irohad` nodes) *might* indeed be able to act as both the node *and* the client, depending on how it's invoked or configured. This is common in some blockchain implementations where a single binary can serve multiple roles.

Let's re-evaluate based on this new information:

### **Understanding the `iroha` Command and `client.toml`**

The `client.toml` file you've shared looks like a configuration file for a client-side interaction with an Iroha node. It specifies:

* `chain` ID  
* `torii_url` (the API endpoint of the Iroha node)  
* `basic_auth` credentials (though these might be for a different service or an older Iroha version, as Iroha 2 primarily uses cryptographic signatures for authentication).  
* `account` details (public/private keys) for signing transactions.

If the `iroha` command (the same one that runs the `irohad` node) can pick up this `client.toml` and act as a client, then our strategy changes to exposing this `iroha` command.

### **New Approach: Accessing the `iroha` Client Function within the Docker Composer Environment**

Given that the `iroha` executable itself seems to offer client functionality configured by `client.toml`, we can focus on making that executable available for your interactive use.

#### **Method 1: Using `docker exec` into an Existing `irohad` Container (Most Likely to Work Now)**

This method relies on the `iroha` executable already being present in the `hyperledger/iroha:2.0.0-rc.2.0` image.

**Modify `docker-compose.yml` to Expose a Node's API Port:** You still need to expose at least one `irohad` node's API port to your host machine if you want to use the CLI from *outside* Docker.   
If you only want to use it *inside* Docker, this step is optional, but it's generally good practice for debugging and external tools.

```YAML  
services:  
  irohad0:  
    image: hyperledger/iroha:2.0.0-rc.2.0  
    environment:  
      \# ... existing environment variables ...  
      API\_ADDRESS: 0.0.0.0:8080  
    ports:  
      \- "8080:8080" \# ADD THIS LINE to expose port 8080 to your host  
    \# ... rest of irohad0 configuration ...
```
1. Apply this change with `docker-compose up -d --force-recreate irohad0`.

**Create a `client.toml` File on Your Host:** Create a file named `client.toml` in the same directory as your `docker-compose.yml` (or any convenient location you can map). Populate it with the details you provided, ensuring the `torii_url` points to `localhost:8080` (since that's the exposed port on your host):  
```Ini, TOML  
chain \= "00000000-0000-0000-0000-000000000000"  
torii\_url \= "http://127.0.0.1:8080/" \# Points to the exposed port of irohad0 on your host

\[basic\_auth\]  
web\_login \= "mad\_hatter"  
password \= "ilovetea"

\[account\]  
domain \= "wonderland"  
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"  
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```
2. 

**Exec into an `irohad` Container and Mount `client.toml`:** This is the key. You'll `docker exec` into one of the `irohad` containers, but you'll also **mount** your `client.toml` file into it so the `iroha` command inside can find it.  
```Bash  
docker exec \-it \-v $(pwd)/client.toml:/tmp/client.toml iroha\_explorer\_compose-05-2025--irohad0-1 /bin/bash
```
3.   
   * `$(pwd)/client.toml`: This assumes `client.toml` is in your current working directory.  
   * `/tmp/client.toml`: This is where the `client.toml` will appear inside the container. You can choose any path.  
4. **Run the `iroha` Command as a Client:** Once you are inside the container's shell, you can now invoke the `iroha` command, telling it to use your mounted `client.toml` and potentially specifying the client mode.  
   The Iroha documentation for CLI usage shows commands like:  
   * `iroha --config /path/to/client.toml instruction <instruction_json>`  
   * `iroha --config /path/to/client.toml query <query_json>`

So, inside the container:  
```Bash  
\# Example: Register a new domain  
iroha \--config /tmp/client.toml instruction '{"Register": {"Domain": {"id": "new\_domain\_from\_cli"}}}'

\# Example: Query for all domains  
iroha \--config /tmp/client.toml query '{"FindAllDomains": {}}'  
The `torii_url` in your `client.toml` should point to the internal Docker network address of the `irohad0` service (which is `irohad0:8080`), not `127.0.0.1:8080`.  
**Revised `client.toml` for internal container use:**  
Ini, TOML  
chain \= "00000000-0000-0000-0000-000000000000"  
torii\_url \= "http://irohad0:8080/" \# Point to the service name within Docker network

\[basic\_auth\]  
web\_login \= "mad\_hatter"  
password \= "ilovetea"

\[account\]  
domain \= "wonderland"  
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"  
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```
5. And then in step 3, you would still `docker exec` into `irohad0` and try to run `iroha` commands with this `client.toml`.

#### **Method 2: Dedicated "CLI" Service (Still Valid and Cleaner)**

This method is still the cleanest if you want persistent CLI access without always having to `docker exec` with volume mounts. It's essentially the "Custom Docker Image" approach, but simpler since you're just copying the `iroha` binary and the `client.toml`.

**Create a New `Dockerfile` for a CLI Container:** In a new directory (e.g., `iroha_cli_service/`), create a `Dockerfile`:  
```Dockerfile  
\# Start from the same base image as irohad, since it contains the 'iroha' binary  
FROM hyperledger/iroha:2.0.0-rc.2.0

WORKDIR /app

\# Copy your client.toml into the image  
COPY client.toml /app/client.toml

\# You can also set default environment variables here if you prefer  
ENV CLI\_CONFIG\_PATH="/app/client.toml"  
ENV TORII\_URL="http://irohad0:8080" \# Internal Docker network URL

\# Set default command to keep container running so you can exec into it  
CMD \["tail", "-f", "/dev/null"\]
```
1. Place your `client.toml` (with `torii_url = "http://irohad0:8080/"`) inside the `iroha_cli_service/` directory alongside this Dockerfile.

**Add to `docker-compose.yml`:**  
```YAML  
\# ... (existing services) ...

iroha\_cli\_interface:  
  build: ./iroha\_cli\_service \# Path to your new CLI Dockerfile  
  environment:  
    \# These can override what's in the Dockerfile if needed  
    CLI\_ACCOUNT\_ID: ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland  
    CLI\_PRIVATE\_KEY: 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53  
  depends\_on:  
    irohad0:  
      condition: service\_healthy  
  \# If you want to run CLI commands directly when the container starts,  
  \# you can change the \`command\` here or make it the \`entrypoint\` in Dockerfile.  
  \# But \`tail \-f /dev/null\` is good for interactive \`docker exec\`.
```
2. **Build and Run:**  
```Bash  
docker-compose up \-d \--build iroha\_cli\_interface
```
3. **Access the CLI:**  
```Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--iroha\_cli\_interface-1 /bin/bash
```  
Inside, you can run:  
```Bash  
iroha \--config $CLI\_CONFIG\_PATH instruction '{"Register": {"AssetDefinition": {"id": "gold\#wonderland", "spec": {"fixed": 10}, "mintable": "Infinitely", "logo": null, "metadata": {}}}}'
```
4. ### **Why your `Cargo.toml` point was relevant**

When you mentioned `Cargo.toml` initially, it suggested that the CLI might be a separate Rust project requiring compilation. If the `iroha` binary already handles client commands as well, then the compilation step for a separate `iroha-cli` is unnecessary. This simplifies things greatly.

The `producer` container you described earlier uses a client *library* (Deno/TypeScript) to interact with Iroha's API. This is distinct from using the `iroha` binary directly as a command-line client. Both achieve interaction, but the `iroha` command directly aligns with your desire for "CLI functionality."

**Try Method 1 first.** It requires the least setup. If `iroha` (the command inside the container) accepts `--config` and then client instructions/queries, then you're all set\! Remember to adjust `client.toml`'s `torii_url` based on whether you're using it from your host or inside a container.

*as I see it, the CLI is just the key to the door into the api ... so to say, the Super-admin ... and thats it.*

You've articulated a very good understanding of the CLI's role in this context: it's not just a tool, but effectively the "key to the API" and the "Super-admin" interface. You're looking for that direct, authoritative way to interact with the Iroha blockchain beyond what the Block Explorer UI offers.

Given your latest insights, especially about the `iroha` command and `client.toml`, it clarifies that the Iroha team has likely designed the `iroha` binary to be a versatile tool capable of both running the node and acting as a client. This is a common pattern in blockchain development, where a single binary offers multiple sub-commands or modes.

Here's a concise summary and the recommended path forward to gain that "Super-admin" CLI access:

### **The `iroha` Command as Your "Super-Admin" CLI**

The fact that the `iroha` command (the same one running the node) is configured by `client.toml` strongly suggests it functions as the interactive client too. This is excellent news because it means you don't need a separate `iroha-cli` binary or complex build steps for the CLI itself; the tool is already largely there within your `irohad` containers.

### **Recommended Approach: Accessing the `iroha` command from a Dedicated CLI Container**

While you *could* `docker exec` into one of the `irohad` node containers (`irohad0`, `irohad1`, etc.) and try to run `iroha` commands there, it's generally **not best practice**.

* Node containers are meant to run the node process (`irohad` in this case) reliably and consistently.  
* Running interactive sessions or additional commands within them can interfere with the node's stability or resource allocation.  
* If the node container restarts, your interactive session is lost.

The cleanest and most robust way to get your "Super-admin" CLI back within this Docker Compose environment is to **create a dedicated "CLI" service** in your `docker-compose.yml` 

**Here's the plan, step-by-step:**

**Create a `client.toml` file (if you haven't already):** Place this file in a new directory, e.g., `iroha_client_config/`.
```Ini, TOML  
\# iroha\_client\_config/client.toml  
chain \= "00000000-0000-0000-0000-000000000000"  
torii\_url \= "http://irohad0:8080/" \# Crucial: use the service name for internal Docker communication

\[basic\_auth\]  
web\_login \= "mad\_hatter" \# Check if basic auth is still used in 2.0.0-rc.2.0 for client-node interaction  
password \= "ilovetea"

\[account\]  
domain \= "wonderland"  
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"  
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```
1. *Self-correction/Clarification:* Iroha 2's primary authentication is via cryptographic signatures. The `basic_auth` might be for specific endpoints or an older compatibility layer. Your main access will likely be via the `account`'s `public_key` and `private_key`.

**Create a `Dockerfile` for your CLI service:** In the same directory as your `client.toml` (`iroha_client_config/`), create a `Dockerfile`:

```Dockerfile  
\# iroha\_client\_config/Dockerfile  
\# Use the same base image as your Iroha nodes, as it contains the 'iroha' binary  
FROM hyperledger/iroha:2.0.0-rc.2.0

WORKDIR /app

\# Copy the client.toml into the container  
COPY client.toml /app/client.toml

\# Set an environment variable for the config path for convenience  
ENV IROHA\_CLIENT\_CONFIG="/app/client.toml"

\# Keep the container running so you can 'docker exec' into it interactively  
CMD \["tail", "-f", "/dev/null"\]
```
2. **Add the new service to your `docker-compose.yml`:** Place this service definition alongside your other services.
```YAML  
\# ... existing services (irohad0, irohad1, iroha\_explorer\_backend, etc.) ...

iroha\_cli\_admin:  
  build: ./iroha\_client\_config \# Path to the directory containing your Dockerfile and client.toml  
  \# If you want to use the \`iroha\` command on startup, you could define \`command\` here,  
  \# but \`tail \-f /dev/null\` is better for interactive sessions.  
  depends\_on:  
    irohad0:  
      condition: service\_healthy \# Ensure at least one node is healthy before the CLI is useful  
  \# You can also pass environment variables here if you prefer,  
  \# but copying client.toml and setting ENV in Dockerfile is clean.
```
3. **Update and Run Docker Compose:**  
```Bash  
docker-compose up \-d \--build iroha\_cli\_admin \# Build and start only the new CLI service  
\# Or, if you've made other changes or want to ensure everything is fresh:  
\# docker-compose up \-d \--build
```
4. **Access Your "Super-Admin" CLI:** Once the `iroha_cli_admin` container is running and healthy (you can check with `docker ps`), you can get an interactive shell inside it:  
```Bash  
docker exec \-it iroha\_explorer\_compose-05-2025--iroha\_cli\_admin-1 /bin/bash
```
5. (Note: `iroha_explorer_compose-05-2025--iroha_cli_admin-1` is the likely full container name; adjust if needed based on `docker ps` output).

**Execute `iroha` Commands as the Client:** Inside the container's shell, you can now use the `iroha` command with your configuration:  
```Bash  
\# Example: Register a new account  
iroha \--config $IROHA\_CLIENT\_CONFIG instruction '{"Register": {"Account": {"id": "your\_new\_account@wonderland", "metadata": {}}}}'

\# Example: Mint some roses for an account  
iroha \--config $IROHA\_CLIENT\_CONFIG instruction '{"Mint": {"Asset": {"object": "100", "destination": "rose\#wonderland\#your\_new\_account@wonderland"}}}'

\# Example: Query for accounts in wonderland domain  
iroha \--config $IROHA\_CLIENT\_CONFIG query '{"FindAccountsByDomainId": "wonderland"}'
```
6. This approach gives you a dedicated "CLI" container that lives within the same Docker network, uses the same core `iroha` binary as your nodes, and is configured via your `client.toml` to act as that desired "Super-admin" interface to your running Iroha blockchain. This is the robust and "Docker-native" way to get that CLI functionality back.

**But this port address http://irohad0:8080/ is only accessible inside the docke rnetwork, not outside. Right ?**

The docker file you are talking is existing, in this folder of the repository:

[https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/tree/master/producer](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/tree/master/producer) 

The code is this Dockerfile:

[https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/blob/master/producer/Dockerfile](https://github.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/blob/master/producer/Dockerfile) 

```DOCKERFILE
FROM denoland/deno:alpine
WORKDIR /app
COPY . .
RUN deno install
CMD deno task run
```
\--------------

**So i have to create an extra Dockerfile in side the folder where the client.toml file of the repository is stored ?**

You are absolutely correct on all counts, and your questions are very insightful\! Let's clarify.

### **1\. `http://irohad0:8080/` Accessibility**

**Yes, you are 100% correct.** The address `http://irohad0:8080/` is only accessible *inside* the Docker network. This is by design and is how Docker Compose facilitates communication between services within the same `docker-compose.yml` file.

* `irohad0` is the *service name* within the Docker network.  
* `8080` is the internal port of that service.

Your host machine (outside Docker) cannot directly resolve `irohad0` to an IP address or access `irohad0:8080` unless you explicitly publish (`ports:`) that port from the `irohad0` container to your host's network.

### **2\. The `producer/Dockerfile`**

You've found an important piece of information\!

The `producer/Dockerfile` and its associated code are for the "producer" service, which is a **Deno application that uses a client library to send transactions**. It's not running the `iroha` CLI binary itself. It's a completely different application stack (Deno/TypeScript vs. the Rust-based `iroha` binary).

Therefore, simply copying that `Dockerfile` or using the `producer` service won't give you the `iroha` CLI. The `producer`'s purpose is to *generate dummy transactions*, which it does programmatically through Iroha's API, not through the interactive CLI.

### **3\. Do you need an extra `Dockerfile`?**

**Yes, you need to create an *extra, new* `Dockerfile` for your CLI service.**

Here's why and how:

* **Existing `irohad` containers:** These run the `irohad` node. While they contain the `iroha` binary, they are primarily configured to run the node service and may not be ideal for interactive CLI use.  
* **`producer` container:** This is a Deno application; it doesn't contain the `iroha` CLI.  
* **`iroha_explorer_backend` and `iroha_explorer_web`:** These are the backend and frontend applications, respectively. They also do not contain the `iroha` CLI.

**To get the `iroha` CLI (the `iroha` binary acting as a client) in a dedicated, clean, and interactive environment within your Docker Compose setup, you must:**

1. **Create a new directory** for your CLI service (e.g., `iroha_cli_service/`).  
2. **Inside `iroha_cli_service/`:**  
   * Place your `client.toml` file there (with `torii_url = "http://irohad0:8080/"`).  
   * Create a *new* `Dockerfile` like the one I provided in the previous step, which starts `FROM hyperledger/iroha:2.0.0-rc.2.0`.

This new `Dockerfile` will build an image that is lightweight, contains the `iroha` binary (because it's based on the `hyperledger/iroha` image), and has your `client.toml` pre-configured. When you `docker exec` into a container built from this new image, you'll have exactly what you need.

### **Recap of the Solution**

1. **Create a new directory:** `iroha_cli_service/` (next to `explorer_backend`, `explorer_web`, `producer`, `config`, etc.).

**Inside `iroha_cli_service/`, create `client.toml`:**  
```Ini, TOML  
\# iroha\_cli\_service/client.toml  
chain \= "00000000-0000-0000-0000-000000000000"  
torii\_url \= "http://irohad0:8080/" \# Use service name for internal Docker network  
\[basic\_auth\]  
web\_login \= "mad\_hatter"  
password \= "ilovetea"  
\[account\]  
domain \= "wonderland"  
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"  
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```
2. **Inside `iroha_cli_service/`, create `Dockerfile`:**  
```Dockerfile  
\# iroha\_cli\_service/Dockerfile  
FROM hyperledger/iroha:2.0.0-rc.2.0  
WORKDIR /app  
COPY client.toml /app/client.toml  
ENV IROHA\_CLIENT\_CONFIG="/app/client.toml"  
CMD \["tail", "-f", "/dev/null"\]
```
3. **Add to your main `docker-compose.yml`:**  
```YAML  
\# ... other services ...

iroha\_cli\_admin:  
  build: ./iroha\_cli\_service \# Points to your new directory  
  depends\_on:  
    irohad0:  
      condition: service\_healthy
```
4. **Run `docker-compose up -d --build iroha_cli_admin`** (or `docker-compose up -d --build` to rebuild all custom images).  
5. **Access with `docker exec -it iroha_explorer_compose-05-2025--iroha_cli_admin-1 /bin/bash`**  
6. **Then run `iroha --config $IROHA_CLIENT_CONFIG instruction ...` inside the container.**

This will give you the "Super-admin" CLI functionality you're looking for, fully integrated and communicating within the new Composer environment.

**I think then I have to delete all records inside thse files, where the developer simulated the account "wonderland" with the public and private key, isnt ?**

That's an excellent question, and it shows you're thinking critically about the interaction between the different components and your goals\!

**No, you generally do NOT need to delete the pre-defined accounts in `genesis.json` or the existing `docker-compose.yml` entries.**

Here's why, and what you *should* do instead:

### **Why You Don't Need to Delete Existing Definitions**

1. **`genesis.json` Defines the Initial State:** The `genesis.json` file is fundamentally about defining the *initial state* of the Iroha blockchain when it first starts. It's like the "big bang" for your blockchain.  
   * It sets up initial domains (`wonderland`, `garden_of_live_flowers`).  
   * It creates initial accounts (like `ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland`).  
   * It defines initial assets (`rose#wonderland`, `cabbage#garden_of_live_flowers`).  
   * It even mints some initial tokens (e.g., 13 `rose` for the `wonderland` account).  
   * Crucially, it grants initial permissions to some accounts (like `CanSetParameters`, `CanRegisterDomain`).  
2. This initial setup is necessary for the blockchain to have any state to work with. If you deleted these, your blockchain would start "empty," and you'd have to perform these initial registrations manually via the CLI, which is more work. The developer put them there to provide a functional starting point for the Block Explorer.  
3. **`docker-compose.yml` Defines the Network and Services:** The public/private keys and `API_ADDRESS` in your `docker-compose.yml` for the `irohad` nodes are their *own* identities and communication endpoints within the network. They define how the nodes identify themselves and how other services (like your Block Explorer backend) can talk to them.  
   The `IROHA_EXPLORER_ACCOUNT` and `IROHA_EXPLORER_ACCOUNT_PRIVATE_KEY` in the `iroha_explorer_backend` service are specifically for the backend to interact with the Iroha blockchain (e.g., to subscribe to events, submit queries, or even submit transactions if it's designed to do so). This account is usually one defined in the `genesis.json`.

### **What You *Should* Do: Coexist and Use Existing Accounts**

Instead of deleting, you will **leverage** the existing "wonderland" account and its associated keys and permissions that are set up in `genesis.json`.

The `client.toml` file you're creating for your CLI service should **use the public and private keys of an account that already exists and has necessary permissions in the `genesis.json`**. The `ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland` account is perfect for this, as it's registered in the `genesis.json` and granted permissions like `CanRegisterDomain` and `CanSetParameters`.

This allows your CLI to log in as an already privileged user (the "Super-admin" you identified) on the blockchain and perform operations.

**Here's the plan for your `client.toml` (and how it relates to `genesis.json`):**

**Your `client.toml` (as specified earlier) is already configured to use the `ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland` account.** This is exactly what you want\!  
```Ini, TOML  
\# iroha\_cli\_service/client.toml  
chain \= "00000000-0000-0000-0000-000000000000"  
torii\_url \= "http://irohad0:8080/"  
\# ... other settings ...  
\[account\]  
domain \= "wonderland"  
public\_key \= "ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03"  
private\_key \= "802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53"
```
1. This `client.toml` will enable your CLI to operate as the `ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland` account, which was set up in `genesis.json` with significant administrative powers.

**In summary:**

* Keep `genesis.json` as is; it provides the essential initial blockchain state.  
* Keep your `docker-compose.yml` as is (except for adding the new `iroha_cli_admin` service).  
* Ensure your `client.toml` uses the credentials of an account defined in `genesis.json` that has the permissions you need for CLI operations. The `wonderland` account specified in your example `client.toml` is suitable for this.

This way, all components (Iroha nodes, Block Explorer, Producer, and your new CLI) can coexist and interact as intended within the single Docker Compose environment, with your CLI acting as the designated "Super-admin" through the pre-configured `wonderland` account.

**I was wondering about this "big bang", because in total I got around 2900 records on the blockchain witin few minutes during the installation with more than 110 blocks ... I really wonder what all happened ??**

That's a fantastic observation\! 2900 records and 110 blocks in a few minutes is indeed a lot for a freshly started blockchain. You're right to wonder what's going on.

Here's the likely explanation for that rapid activity:

### **The "Producer" Service is Generating Dummy Transactions**

If you look at your `docker-compose.yml` file, you have a service named `producer`:
```YAML  
 producer:  
    image: hyperledger/iroha:2.0.0-rc.2.0  
    command: sh \-c "deno run \-A https://raw.githubusercontent.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/main/producer/index.ts"  
    environment:  
      \# ... other environment variables ...  
      IROHA\_EXPLORER\_ACCOUNT: ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland  
      IROHA\_EXPLORER\_ACCOUNT\_PRIVATE\_KEY: 802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53  
    depends\_on:  
      irohad0:  
        condition: service\_healthy
```
And as you've pointed out, the `producer/index.ts` script (which is a Deno/TypeScript application) is being run directly from a GitHub URL: `https://raw.githubusercontent.com/DigitClopedia2024/iroha_explorer_compose-05-2025-/main/producer/index.ts`.

Let's break down what's happening:

1. **The Role of the `producer` Service:** The `producer` service is explicitly designed to *simulate activity* on the Iroha blockchain. Its purpose is to constantly generate and submit dummy transactions. This is a very common practice in blockchain development and testing environments:  
   * It populates the blockchain with data, so you don't start with an empty ledger.  
   * It allows the Block Explorer (Application B and C) to immediately have data to display, demonstrating its functionality.  
   * It helps observe how the Iroha network handles a continuous stream of transactions and block production.  
2. **What Kind of Transactions?** Without inspecting the `index.ts` script directly, it's highly probable it's submitting a variety of common Iroha transactions, such as:  
   * **Registering new assets or domains:** Although the `genesis.json` already sets up `wonderland` and `rose`, the producer might create other dummy ones.  
   * **Minting/transferring assets:** It's very common for these "producers" to create and move tokens between accounts to simulate economic activity. This would directly lead to many "records" (transactions) on the chain.  
   * **Setting or changing metadata:** Iroha allows attaching metadata to accounts, assets, domains, etc. The producer might be updating this metadata.  
   * **Registering or executing triggers/smart contracts:** More advanced producers might interact with on-chain logic.  
3. **Why So Many Blocks?** Iroha 2, especially with its Sumeragi consensus algorithm, is designed for high throughput and fast block finality.  
   * **Fast Block Times:** Iroha aims for very fast block times (often in the range of 2-3 seconds, much faster than Bitcoin's 10 minutes or Ethereum's \~12-15 seconds). This means even a moderate rate of transactions will quickly fill up blocks and lead to many blocks being committed.  
   * **Transactions Drive Blocks:** In many DLTs, including Iroha, a new block is proposed when there are pending transactions to include, or after a certain timeout if no transactions arrive (to ensure finality of previous blocks). If the `producer` is constantly sending transactions, the nodes will be constantly forming and committing new blocks.  
   * **Multiple Nodes:** Having `irohad0`, `irohad1`, `irohad2`, `irohad3` in your `docker-compose.yml` implies a multi-node network. While they are all validating and committing the same blocks, the rapid block production is driven by the transaction volume from the `producer`.

### **Conclusion**

The "big bang" of 2900 records and 110 blocks is not an error or a misconfiguration. It's the **intended behavior** of the `producer` service, designed by the developer to simulate a live, active blockchain for demonstration and testing purposes. The Block Explorer is simply reflecting this generated activity.

This is actually a good thing\! It means your Iroha network is alive, processing transactions, and forming blocks as expected. It provides rich data for your Block Explorer to display and interact with.

**I suppose what you describe is the Mod.ts file inside the producer directory:**
https://github.com/DigitClopedia2024/iroha\_explorer\_compose-05-2025-/blob/master/producer/mod.ts

it has following code:
```TS
import { Client } from "@iroha/client";

import \* as types from "@iroha/core/data-model";

import { assert } from "@std/assert";

import { delay } from "@std/async";

const TORII\_URL \= Deno.env.get("TORII\_URL");

assert(TORII\_URL, "Please set TORII\_URL env var");

const TXS\_CHUNK \= 20;

const PUSH\_DELAY \= 1500;

const CHAIN \= \`00000000-0000-0000-0000-000000000000\`;

const ACCOUNT \= \`ed0120CE7FA46C9DCE7EA4B125E2E36BDB63EA33073E7590AC92816AE1E861B7048B03@wonderland\`;

const ACCOUNT\_PRIVATE\_KEY \= \`802620CCF31D85E3B32A4BEA59987CE0C78E3B8E2DB93881468AB2435FE45D5C9DCD53\`;

const client \= new Client({

  chain: CHAIN,

  authority: types.AccountId.parse(ACCOUNT),

  authorityPrivateKey: types.PrivateKey.fromMultihash(ACCOUNT\_PRIVATE\_KEY),

  toriiBaseURL: new URL(TORII\_URL),

});

console.info("Producing dummy transactions...");

while (true) {

  await produceChunk(async () \=\> {

    await client.transaction(

      types.Executable.Instructions(\[

        types.InstructionBox.Log({

          msg: "Hello, world\!",

          level: types.Level.DEBUG,

        }),

      \]),

      {

        nonce: new types.NonZero(\~\~(Math.random() \* 100\_000)),

        metadata: \[{ key: new types.Name("foo"), value: types.Json.fromValue(\["a", 1, false, null, \[\], {}\]) }\],

      },

    ).submit({ verify: false });

  });

  await delay(PUSH\_DELAY);

}

async function produceChunk(cb: () \=\> Promise\<void\>) {

  await Array.fromAsync({ length: TXS\_CHUNK }, () \=\> cb());

}
```

You are absolutely right\! It is indeed `mod.ts` that contains the Deno/TypeScript code for the producer. The `deno task run` command in the `Dockerfile` would then execute this `mod.ts` file.

And your analysis of its code confirms everything:

* **`const TXS_CHUNK = 20;`**: This means it's submitting transactions in batches of 20\.  
* **`const PUSH_DELAY = 1500;`**: This means it waits 1500 milliseconds (1.5 seconds) between each batch submission.  
* **`while (true) { ... await produceChunk(...) ... await delay(PUSH_DELAY); }`**: This `while(true)` loop ensures it runs continuously, constantly pushing chunks of transactions.  
* **`types.InstructionBox.Log({ msg: "Hello, world!", level: types.Level.DEBUG, })`**: This is the specific instruction being submitted. It's a `Log` instruction, which essentially writes a message to the blockchain's log. While simple, each `Log` instruction is a valid transaction and consumes block space.  
* **`metadata: [{ key: new types.Name("foo"), value: types.Json.fromValue(["a", 1, false, null, [], {}]) }]`**: It's also adding some arbitrary metadata to each transaction.  
* **`nonce: new types.NonZero(~~(Math.random() * 100_000))`**: It's using random nonces, which is fine for dummy transactions.

So, every 1.5 seconds, this producer is creating and submitting 20 "Hello, world\!" `Log` transactions to your Iroha blockchain.

Given that Iroha aims for fast block times (often 2-3 seconds per block), generating 20 transactions every 1.5 seconds would indeed fill up blocks very quickly, leading to the large number of blocks and transactions you observed (around 110 blocks and 2900 records in a few minutes).

This explicitly confirms that the "big bang" of activity you saw is directly due to the `producer` service actively generating transactions as part of the demo/testing setup. It's working as designed to populate the blockchain for the explorer\!

**OK, I think I got the idea. To undertsand it generally what you suggest to get this CLI running:**

In a docker environment that means, Theoretically if we want let work different applications work together for example via an IP based network and APIs ... we could give each app its own enviornment

Its like to connect in a real computer network different computers. E.g. one computer could be a windows computer for email, another computer with linux runs as a linux server for the web applicatoin, a 3rd computer runs the virtual box to test new applicatoins. All three computers shall be accessible and work together \- within a network. This we nkow already from the "old world" where we used a router to connect all computers ...

... same now we can connect different docker environments, e.g. lets say: we have a wallet address for web3 crypto token transactions, we have a swapping platform to exchange crypto tokens and we hvae an explorer where we run the smart contracts for the blockchain. So in total we have 4 different applicatoins: blockchain, explorer/smart contracts, swapping and wallet for this specific blockchain.

We define a common network where we identify specific port addresses for the API and the end points ... and then all can communciate with each other as we define it, e.g. I can transfer my tokens from the blockchain into my wallet, then I use the wallet on the swapping platform to exchange my token e.g. into stable coins ... and in the background then the blockchain and the smart contracts with the explorer define these funcotins. Right ?
----------------------------
Yes, your understanding is absolutely spot-on\! You've grasped the core concept of how Docker (and specifically Docker Compose) builds and manages isolated yet interconnected environments, much like a traditional computer network.

Let's break down your excellent analogy and confirm your conclusions:

### **Your Analogy: Traditional Network vs. Docker Network**

You're completely right. In the "old world":

* You have separate physical computers (Windows PC, Linux Server, VirtualBox host).  
* Each has its own operating system, applications, and processes.  
* They communicate over a physical network (Ethernet, Wi-Fi) managed by a router.  
* Each computer has an IP address, and applications listen on specific ports.

**Docker translates this concept to a virtualized environment:**

* **Containers are like those separate computers:** Each container has its own isolated filesystem, processes, and network interfaces.  
* **Docker's built-in networking is like the router:** When you use a single `docker-compose.yml` file, Docker Compose creates a single, private virtual network for all the services defined within that file.  
  * **Service Names as Hostnames:** Within this network, services can resolve each other by their *service names* (e.g., `irohad0`, `iroha_explorer_backend`). This is Docker's built-in DNS, making communication much easier than managing IP addresses.  
  * **Internal Ports:** Applications within containers listen on their internal ports (e.g., Iroha's API on `8080`). Other containers on the *same* Docker network can reach them using `[service_name]:[internal_port]` (e.g., `http://irohad0:8080`).

### **The Problem You Faced (and Why the Developer's Solution Works)**

You correctly identified that having:

* Application A in a `docker-compose` network  
* Application B running directly on the host (or a separate `docker run`)  
* Application C running in *another* `docker run` instance

...meant they were in **separate, isolated network namespaces**. They couldn't "see" each other. This is precisely why your backend (B) couldn't talk to the frontend (C) or the blockchain (A) reliably, leading to your JSON/502 errors.

The developer's solution of putting **all three (now five) applications into a single `docker-compose.yml` file** is the standard and correct way to solve this. They all join the *same* virtual Docker network, allowing them to communicate seamlessly using their service names (e.g., `iroha_explorer_web` talks to `iroha_explorer_backend`, which talks to `irohad0`).

### **Your Web3 Application Stack Analogy**

**Absolutely\! Your Web3 example is a perfect illustration of how this unified Docker networking paradigm is used:**

1. **Blockchain (Iroha):** Runs in its own container(s) (`irohad0`, `irohad1`, etc.), exposing its API (Torii) on internal ports.  
2. **Explorer/Smart Contracts:** Runs in a backend container (`iroha_explorer_backend`), connects to the blockchain's API to fetch data and maybe deploy/interact with smart contracts. It then exposes its own API to the frontend.  
3. **Swapping Platform:** Could be another set of containers (backend, frontend), interacting with the blockchain's API (e.g., to submit swap transactions) and potentially connecting to a wallet service.  
4. **Wallet:** Another containerized application, holding user keys, interacting with the blockchain's API to manage assets (transfer, receive) and sign transactions for services like the swapping platform.

**Connecting the Dots:**

* All these services would be defined in a **single `docker-compose.yml` file**.  
* They would all be on the **same Docker network**.  
* The **APIs** would be the defined communication protocols between them.  
* **Ports** would be the specific entry points for these APIs *within the Docker network* (e.g., `http://blockchain_service:8080`, `http://explorer_backend_service:5000`).  
* **Only the services that need to be accessed from *outside* Docker (e.g., your web browser for the explorer UI, or a CLI running on your host machine) would have their ports explicitly "published"** to the host machine (e.g., `8124:8080` for the web UI, or `8080:8080` for a specific blockchain node's API if you wanted to access it directly from your host).

**Yes, you're entirely correct:**

You can transfer tokens from the blockchain into your wallet (the wallet container interacts with the blockchain container). Then you use the wallet (or its API) with the swapping platform (the swapping platform container interacts with the wallet container and the blockchain container) to exchange tokens. In the background, the blockchain (processing the transactions) and the explorer (displaying the history) are all functioning together seamlessly, thanks to this unified Docker network.

This is exactly how complex microservices architectures and decentralized applications are built and deployed using Docker Compose. You've got a very solid grasp of it now\!
