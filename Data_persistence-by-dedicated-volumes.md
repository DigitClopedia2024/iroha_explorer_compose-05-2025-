# README: Iroha V2 Persistent Blockchain Data (Docker Compose)

This document addresses a critical operational issue within the `iroha_explorer_compose` Docker Compose setup: **the loss of blockchain data when Iroha V2 containers are removed or recreated.** This issue manifests as containers getting stuck in "waiting" states or becoming "unhealthy" during startup, especially when other services attempt to interact with a seemingly empty or uninitialized blockchain.

## Introduction & Context

For any production-ready blockchain system, particularly one managing high-value assets (7-8 figures), **data persistence is non-negotiable.** Without it, every time your `irohad` (Iroha node) containers are restarted or rebuilt, the entire blockchain ledger, history, and state are wiped clean. This leads to:

* **Data Loss:** All previously committed blocks and transactions are lost.
* **Operational Instability:** Nodes cannot resume from a known state, leading to prolonged initialization, inconsistent behavior, and "unhealthy" statuses as other services expect a functioning chain.
* **Lack of Auditability:** The continuous loss of historical data makes auditing impossible.

This document provides a crucial solution by guiding you through the process of adding dedicated persistent volumes for your Iroha V2 blockchain data within the Docker Compose environment. This complements previous `healthcheck` adjustments, providing a more fundamental fix for node stability.

## The Problem: Non-Persistent Data

In your current `docker-compose.yml`, the `volumes` configuration for `irohad0` (and likely `irohad1`, `irohad2`, `irohad3`) includes: `- ./config:/config:ro`. This entry correctly mounts your local `config` directory into the container as read-only, which is suitable for immutable configuration files.

However, this configuration **does not store the blockchain's mutable data**. The actual blocks, transaction history, and node state are written to a different directory inside the container (commonly `/var/lib/iroha` for Iroha V2). Without a specific volume mapping for this data directory, Docker treats it as ephemeral storage. Consequently, when `docker compose up -d` is run (which often recreates containers), or even sometimes `docker compose start` attempts to resume a container instance that started from an empty state due to previous recreation, the node finds an empty ledger. This leads to:

* `irohad0` (and other nodes) getting stuck in a "waiting" state.
* Eventually transitioning to "unhealthy" because it cannot fully initialize or meet the expectations of dependent services like `producer` or `iroha_cl_admin` (which expect an active blockchain).

## Prerequisites

Before proceeding, ensure you have:

* **Docker and Docker Compose** installed and configured in your environment (e.g., VirtualBox/Debian 12).
* **Access to the `docker-compose.yml` file** for this Iroha V2 setup in your repository.

## Solution: Implementing Persistent Volumes for Iroha Nodes

To ensure your blockchain data is never lost and your Iroha nodes can reliably restart from their last known state, you must add dedicated persistent volumes. The common internal data path for Iroha V2 nodes is `/var/lib/iroha`.

You have two main options for implementing these volumes:

### Option 1: Docker Named Volumes (Recommended)

This is the preferred method for managing persistent data with Docker Compose. Docker handles the creation and management of these volumes, making your setup more portable across different environments.

1.  **Define Named Volumes:** Add a `volumes` section at the top level of your `docker-compose.yml` (usually after `services:` and before `networks:`). Define a unique named volume for each Iroha node (`irohad0`, `irohad1`, `irohad2`, `irohad3`) to ensure their data is isolated.

  ```yaml
    # Add this section at the top level of your docker-compose.yml
    # (e.g., directly below the 'services:' block, before 'networks:')
    volumes:
      iroha_data_0:
      iroha_data_1:
      iroha_data_2:
      iroha_data_3:
  ```
Here's how your docker-compose.yml structure would look, highlighting where the top-level volumes: block should go if you chose Option 1 (Docker Named Volumes):

  ```yaml
    # TODO: set up shutdown/restart policies
    services:
      # Iroha
      #
      # NOTE: These are mostly generated by `kagami swarm`
      irohad0:
        image: hyperledger/iroha:2.0.0-rc.2.0
        environment:
          # ... your existing environment variables ...
        volumes:
          - ./config:/config:ro
          - ./data/irohad0:/var/lib/iroha # This line stays here for bind mounts
          # OR - iroha_data_0:/var/lib/iroha # This line would be here for named volumes
        init: true
        healthcheck:
          # ... your healthcheck config ...
        command: |-
          # ... your command ...
  
          # ... other services like irohad1, irohad2, irohad3, producer, iroha_cl_admin ...

        # --- THIS IS WHERE THE TOP-LEVEL 'volumes:' BLOCK GOES IF YOU USE NAMED VOLUMES (Option 1) ---
        volumes: # This 'volumes' key must be at the same indentation level as 'services:'
          iroha_data_0: # These are the named volumes defined here
          iroha_data_1:
          iroha_data_2:
          iroha_data_3:

        # If you have a networks block, it would be here, also at the top level:
        # networks:
        #   default:
        #     name: iroha_network
        # ... etc ...
  ```

2.  **Mount Named Volumes to Services:** Update the `volumes` section for *each* `irohad` service (`irohad0`, `irohad1`, `irohad2`, `irohad3`) to mount its respective named volume to the Iroha data path (`/var/lib/iroha`) inside the container.

    ```yaml
    services:
      irohad0:
        # ... your existing irohad0 configuration ...
        volumes:
          - ./config:/config:ro
          - iroha_data_0:/var/lib/iroha # Add this line
        # ... rest of irohad0 config ...

      irohad1:
        # ... your existing irohad1 configuration ...
        volumes:
          - ./config:/config:ro
          - iroha_data_1:/var/lib/iroha # Add this line
        # ... rest of irohad1 config ...

      irohad2:
        # ... your existing irohad2 configuration ...
        volumes:
          - ./config:/config:ro
          - iroha_data_2:/var/lib/iroha # Add this line
        # ... rest of irohad2 config ...

      irohad3:
        # ... your existing irohad3 configuration ...
        volumes:
          - ./config:/config:ro
          - iroha_data_3:/var/lib/iroha # Add this line
        # ... rest of irohad3 config ...
    ```

### Option 2: Bind Mounts to Host Directories

This option mounts a specific directory on your host machine directly into the container. This makes it easy to inspect the data on your host, but it can be less portable and requires you to manage the host directories.

* **Mount Host Directories to Services:** Update the `volumes` section for *each* `irohad` service (`irohad0`, `irohad1`, `irohad2`, `irohad3`) to create a distinct data directory on your host and mount it to `/var/lib/iroha` inside the container.

    ```yaml
    services:
      irohad0:
        # ... your existing irohad0 configuration ...
        volumes:
          - ./config:/config:ro
          - ./data/irohad0:/var/lib/iroha # Add this line. Creates 'data/irohad0' in your project root.
        # ... rest of irohad0 config ...

      irohad1:
        # ... your existing irohad1 configuration ...
        volumes:
          - ./config:/config:ro
          - ./data/irohad1:/var/lib/iroha # Add this line
        # ... rest of irohad1 config ...

      irohad2:
        # ... your existing irohad2 configuration ...
        volumes:
          - ./config:/config:ro
          - ./data/irohad2:/var/lib/iroha # Add this line
        # ... rest of irohad2 config ...

      irohad3:
        # ... your existing irohad3 configuration ...
        volumes:
          - ./config:/config:ro
          - ./data/irohad3:/var/lib/iroha # Add this line
        # ... rest of irohad3 config ...
    ```
    **Note:** For bind mounts, ensure the specified host directories (e.g., `./data/irohad0`) exist in the same location as your `docker-compose.yml` file, or Docker Compose will create them automatically.

## Step-by-Step Implementation Guide

Follow these steps to apply the persistent volume configuration to your Iroha V2 setup:

1.  **Choose a Volume Option:** Decide whether you want to use Docker Named Volumes (recommended) or Bind Mounts to Host Directories.
2.  **Edit `docker-compose.yml`:**
    * If using **Docker Named Volumes**, add the top-level `volumes:` section as shown in Option 1. 
    *  For **Docker Bind Mount** option 2 you dont need to ad the top-level volumes, just add the specific code line to the volumes definition itself as described (e.g. ./data/irohad0:/var/lib/iroha ). 
    * For **both** options, update the `volumes:` section for *each* of your `irohad0`, `irohad1`, `irohad2`, and `irohad3` services, adding the new line that maps the persistent data path to `/var/lib/iroha` (or your specific Iroha data path).
3.  **Save the `docker-compose.yml` file.**
4.1  **File Permissions for data/irohadX Directories**

When you create directories like project-name/data/irohad0 with sudo mkdir, they are owned by root (owner: root, group: root).

*Problem*: The process running inside your irohad0 Docker container typically does not run as the root user for security reasons. If the irohad application inside the container tries to write its blockchain data to /var/lib/iroha (which is mapped to your project-name/data/irohad0 on the host), and that host directory is only writable by root, the irohad process will encounter a "Permission Denied" error. This will absolutely lead to conflicts and prevent the container from becoming healthy, as it cannot write its essential data.

*Solution*: You need to change the ownership of these host directories so that the user inside the Docker container has write permissions. The simplest and most common solution is to change the ownership of your data directory (and its contents) to the user you are running docker compose with on your host machine.

Assuming you are running *docker compose* as your regular user (e.g., yourusername) by using sudo docker compose ..., you should change the ownership of the data directory to your user:

```Bash
sudo chown -R $USER:$USER project-name/data
```
sudo chown: Change owner command.
-R: Recursive, applies to all subdirectories and files.
$USER:$USER: This is a shell variable that expands to your current username and your primary group. This sets both the owner and the group to your user.
project-name/data: The path to your data directory that contains irohad0, irohad1, etc.

After changing the ownership, irohad processes inside the containers will be able to write to these directories, resolving the permission conflicts.

4.2 **Anomalies** 

with start of the docker compose system and the upper pathes of option 2 the logs showed blocks being committed and snapshots created, and that the web UI was working! This confirmed the Iroha nodes have indeed processed transactions.

Yet, the fact that the host directories (./data/irohad0, etc.) remained empty was the key anomaly here. This strongly suggested that the data was being written to a different location inside the Docker container than the /var/lib/iroha path we've currently mapped.

Based on recent Iroha V2 configurations, it appears that the default block store path has moved or is configurable. Specifically, the *storage engine* **Kura** (which the logs mention: iroha_core::kura: Kura init complete) often uses */storage* as its block store path by default, or it's controlled by an environment variable like *KURA_BLOCK_STORE_PATH*.

The strong suspicion is that /var/lib/iroha is no longer the correct internal path for Iroha V2's blockchain data in our specific image version (2.0.0-rc.2.0). It is more likely to be */storage.*

*Recommended Action*: **Update the Internal Container Path in docker-compose.yml**
We try modifying our docker-compose.yml file to change the internal path of the bind mounts from /var/lib/iroha to /storage for irohad0, irohad1 till irohad3. Then follow again with following 5. and let do the command *docker compose up -d --build* on its own to create the new storage folders.

5.  **Apply Changes and Recreate Containers:**
    * It is **CRUCIAL** to stop and remove your existing containers so that new ones can be created with the correct volume attachments.
    * Open your terminal in the directory where your `docker-compose.yml` file is located and run:
        ```bash
        docker compose down # This stops and removes ALL current containers and their non-persisted data.
        docker compose up -d --build # This will create brand new containers with the volumes attached and start them.
        ```
    * The `--build` flag ensures that if any image definitions have changed, they are rebuilt, and it guarantees that new containers are created with your updated volume configurations.

## Verification

After executing `docker compose up -d --build`:

1.  **Check Container Status:**
    ```bash
    docker ps
    ```
    Verify that all `irohad` containers are in a `healthy` state (this may take some time depending on your `healthcheck` settings).

2.  **Check Logs:**
    ```bash
    docker logs irohad0 # Check logs for irohad0, then other irohad nodes
    ```
    Look for messages indicating successful initialization and block production without errors related to missing data.

3.  **Confirm Data Persistence:**
    * Let the system run for a bit, creating some blocks/transactions.
    * Then, stop all services: `docker compose stop`
    * Start them again: `docker compose start`
    * Verify that the blockchain state (e.g., block height, existing assets) is preserved and the nodes do not start from an empty ledger.

By implementing these persistent volumes, you establish a foundational layer of data integrity, significantly improving the stability and reliability of your Iroha V2 blockchain environment. This is a vital step towards building the robust and auditable system required for high-value asset management.
